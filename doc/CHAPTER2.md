#Interworking with your SDN controller

MD-SAL is basically YANG datastore with DCN(pubsub) and RPC support.

If your SDN controller also follows this kind of data-driven architecture, it is possible to connect your SDN controller to MD-SAL via some kind of gateway:

```
[Your SDN controller]---pubsub(such as Redis)---[GW plugin]<-CRUD/DCN->[MD-SAL]

```

###Data-driven architecture
Usually, SDN controllers internally have datastore supporting pubsub:
- A combination of ZooKeeper and Cassandra
- A combination of Redis and another datastore
- Hazelcast
- MD-SAL
- And many others...

You may also add MongoDB and etcd to the list.

Plugins attached to datastore communicate with each other indirectly via the datastore's pubsub feature.

###The GW's role
- The construct is sort of clustering (ACT-ACT).
- OpenDaylight's CRUD/DCN is seen as MESSAGE on Redis.
- The GW subscribes channels on MD-SAL and Redis for example.
- The GW works as a pubsub relay and data model translator: translation between your data model schema (e.g., defined in your Java classes) and YANG Java binding generated by ODL YANG Tools.
- The data on Your SDN controller's datastore are synchronized with MD-SAL datastore via the GW.
- Users may use both your SDN controller's N.B. API and OpenDaylight's RESTCONF API.

##Coodination of SDN controllers
If everythings work in a same container (such as Karaf container), things are easy. If not, you may need to use something like ZooKeeper or etcd (or MD-SAL?) for coordinating SDN controllers.

Recommendation 1:

1. Run you SDN controller as a Karaf feature (a combination of OSGi bundles) and OpenDaylight in a same Karaf container (i.e., on a same JVM).
2. Use "embedded" pubsub server or develop a pubsub capability on your own, and avoid using an external pubsub server (such as Redis).

```
+------------+
| [Feature]  |
| [Feature]  |
| [Feature]  |
+------------+
Karaf OSGi container (limited to Java)
```

Recommendation 2:

Given that part of SDN software engineers are migrating to Golang community these days, what if you like Python or Golang to develop your SDN controller? In this case, Java-olny OSGi becomes meaningless and another choice is to use a PaaS infrastructure and chose your favorite pubsub or MQ (Redis, RabbitMQ, ActiveMQ etc) and database (SQL or NoSQL). PaaS also supports rolling update and load balancer capabilites required for a commercial deployment.

```
[Feature]  [Feature]  [Feature]
Container  Container  Container
    |          |          |
   -+------+---+----------+-- pubsub or MQ
           |
 [router/load balancer]
           |
   production network

Linux Container for every feature
```

##Transaction/Rollback

Consider how to implement transaction/rollback.

Is this MD-SAL API still valid? https://git.opendaylight.org/gerrit/#/c/12912/9

Is MD-SAL architecture right from a view point of transaction/rollback for networking equipment configuration?

##Your SDN controller is sort of a southbound plugin for MD-SAL

Compare!
```
          [MD-SAL]                         [MD-SAL]
             |                                |
    [Your SDN controller]                 [Driver]
             |                                |
    [Your networking equipment]   [Your networking equipment]
```
You must have noticed that there are no differences between the above two.

SDN is about synchronizing data between MD-SAL and networking equipment.

What about this?
```
          [MD-SAL]                         [MD-SAL]
             |                                |
             X Disconnected               [Driver]
             |                                |
    [Your SDN controller]                     X Disconnected
             |                                |
    [Your networking equipment]   [Your networking equipment]
```
Network partition (split-brain case) causes data conflict (out of sync) between MD-SAL and your SDN controller or MD-SAL and networking equipment, and that is something we have to take into account seriously.

If you use OpenDaylight as OpenFlow Controller, you don't need to consider the conflict problem above, because all the flows on the swich are stateless (ephemeral), although all the PacketIn are dropped and new flows are never created.

##APIC-EM

When I was writing code for this project, I happend to see APIC-EM architecture.

APIC-EM seems to use MD-SAL for device abstraction (CLI/SNMP) and use some messaging APIs to communicate with other components via message bus (AMQP). So OpenDaylight/MD-SAL is just a device driver for APIC-EM.

Note: the current GA release of APIC-EM does not seem to include MD-SAL.

APIC-EM components run in Linux containers (LXC) managed by PaaS program called "Grapevine". It seems to use SQL (for application config?) and NoSQL (cassandra for PaaS config?) databases to store data. I can find databases in its open source list: Cassandra, Postgresql and Hazelcast. I can also find that APIC-EM is based on Spring framework, so you can use either REST API or message bus (AMQP, Redis or whatever) to use APIC-EM features from your app.

Links:
- [APIC-EM GA Release is Here!](https://communities.cisco.com/community/developer/networking/cisco-one/apic-em/blog/2015/11/04/apic-em-ga-release-is-here)
- [APIC-EM product documentation](http://www.cisco.com/c/en/us/products/cloud-systems-management/application-policy-infrastructure-controller-enterprise-module/index.html)
- [Enterprise SDN -- Infonetics research](http://www.wallstreet-online.de/nachricht/7545668-infonetics-north-american-businesses-plan-to-have-sdn-live-the-lan-by-2017)
- [OpenDaylight Messaging4Transport](https://wiki.opendaylight.org/view/Messaging4Transport:Main)
